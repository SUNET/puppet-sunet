diff --git a/manifests/dockerhost.pp b/manifests/dockerhost.pp
index 3c48d35f..2c7dca98 100644
--- a/manifests/dockerhost.pp
+++ b/manifests/dockerhost.pp
@@ -2,7 +2,7 @@
 class sunet::dockerhost(
   String $docker_version,
   String $docker_package_name                 = 'docker-engine',  # facilitate transition to new docker-ce package
-  Enum['stable', 'edge', 'test', 'none'] $docker_repo = 'stable',
+  Enum['stable', 'edge', 'test'] $docker_repo = 'stable',
   $storage_driver                             = undef,
   $docker_extra_parameters                    = undef,
   Boolean $run_docker_cleanup                 = true,
@@ -12,30 +12,31 @@ class sunet::dockerhost(
   Boolean $ufw_allow_docker_dns               = true,
   Boolean $manage_dockerhost_unbound          = false,
   String $compose_image                       = 'docker.sunet.se/library/docker-compose',
-  String $compose_version                     = '1.15.0',
+  String $compose_version                     = '1.24.0',
   Optional[Array[String]] $tcp_bind           = undef,
+  Boolean $write_daemon_config                = false,
+  Boolean $enable_ipv6                        = false,
 ) {
+  if versioncmp($::operatingsystemrelease, '22.04') <= 0 {
+    # Remove old versions, if installed
+    package { ['lxc-docker-1.6.2', 'lxc-docker'] :
+      ensure => 'purged',
+    }
 
-  # Remove old versions, if installed
-  package { ['lxc-docker-1.6.2', 'lxc-docker'] :
-    ensure => 'purged',
-  }
+    file {'/etc/apt/sources.list.d/docker.list':
+      ensure => 'absent',
+    }
 
-  file {'/etc/apt/sources.list.d/docker.list':
-    ensure => 'absent',
-  }
+    if $docker_package_name != 'docker-engine' and $docker_package_name != 'docker.io' {
+      # transisition to docker-ce
+      exec { 'remove_dpkg_arch_i386':
+        command => '/usr/bin/dpkg --remove-architecture i386',
+        onlyif  => '/usr/bin/dpkg --print-foreign-architectures | grep i386',
+      }
 
-  if $docker_package_name != 'docker-engine' {
-    # transisition to docker-ce
-    exec { 'remove_dpkg_arch_i386':
-      command => '/usr/bin/dpkg --remove-architecture i386',
-      onlyif  => '/usr/bin/dpkg --print-foreign-architectures | grep i386',
+      package {'docker-engine': ensure => 'purged'}
     }
 
-    package {'docker-engine': ensure => 'purged'}
-  }
-
-  if $docker_repo != 'none' {
     # Add the dockerproject repository, then force an apt-get update before
     # trying to install the package. See https://tickets.puppetlabs.com/browse/MODULES-2190.
     #
@@ -50,6 +51,7 @@ class sunet::dockerhost(
     apt::key { 'docker_ce':
       id     => '9DC858229FC7DD38854AE2D88D81803C0EBFCD88',
       source => '/etc/cosmos/apt/keys/docker_ce-8D81803C0EBFCD88.pub',
+      notify => Exec['dockerhost_apt_get_update'],
     }
 
     if $::operatingsystem == 'Ubuntu' and $::operatingsystemrelease == '14.04' {
@@ -65,34 +67,30 @@ class sunet::dockerhost(
       repos        => $docker_repo,
       key          => {'id' => '9DC858229FC7DD38854AE2D88D81803C0EBFCD88'},
       architecture => $architecture,
+      notify       => Exec['dockerhost_apt_get_update'],
     }
+  }
 
-    if $docker_version =~ /^\d.*/ {
-      # if it looks like a version number (as opposed to 'latest', 'installed', ...)
-      # then pin it so that automatic/manual dist-upgrades don't touch the docker package
-      apt::pin { 'docker-ce':
-        packages => $docker_package_name,
-        version  => $docker_version,
-        priority => 920,  # upgrade, but do not downgrade
-        notify   => Exec['dockerhost_apt_get_update'],
-      }
+  if $docker_version =~ /^\d.*/ {
+    # if it looks like a version number (as opposed to 'latest', 'installed', ...)
+    # then pin it so that automatic/manual dist-upgrades don't touch the docker package
+    apt::pin { 'docker package':
+      packages => $docker_package_name,
+      version  => $docker_version,
+      priority => 920,  # upgrade, but do not downgrade
+      notify   => Exec['dockerhost_apt_get_update'],
     }
+  }
 
-    exec { 'dockerhost_apt_get_update':
-      command     => '/usr/bin/apt-get update',
-      cwd         => '/tmp',
-      require     => [Apt::Key['docker_ce']],
-      subscribe   => [Apt::Key['docker_ce']],
-      refreshonly => true,
-    }
-    package { $docker_package_name :
-      ensure  => $docker_version,
-      require => Exec['dockerhost_apt_get_update'],
-    }
-  } else {
-    package { $docker_package_name :
-      ensure  => $docker_version,
-    }
+  exec { 'dockerhost_apt_get_update':
+    command     => '/usr/bin/apt-get update',
+    cwd         => '/tmp',
+    refreshonly => true,
+  }
+
+  package { $docker_package_name :
+    ensure  => $docker_version,
+    require => Exec['dockerhost_apt_get_update'],
   }
 
   if $docker_package_name == 'docker-ce' {
@@ -116,6 +114,7 @@ class sunet::dockerhost(
 
   package { [
     'python3-yaml',  # check_docker_containers requirement
+    'jq',            # restart_unhealthy_containers requirement
   ] :
     ensure => 'installed',
   }
@@ -150,21 +149,70 @@ class sunet::dockerhost(
     $tls_key = undef
   }
 
-  class {'docker':
-    storage_driver              => $storage_driver,
-    manage_package              => false,
-    manage_kernel               => false,
-    use_upstream_package_source => false,
-    dns                         => $_docker_dns,
-    extra_parameters            => $docker_extra_parameters,
-    docker_command              => $docker_command,
-    daemon_subcommand           => $daemon_subcommand,
-    tcp_bind                    => $_tcp_bind,
-    tls_enable                  => $tls_enable,
-    tls_cacert                  => $tls_cacert,
-    tls_cert                    => $tls_cert,
-    tls_key                     => $tls_key,
-    require                     => Package[$docker_package_name],
+  # This is an approximation about how to enable IPv6 in Docker, but
+  # BEWARE! IPv6 is currently utterly dysfunctional in docker-compose (version 3 / 1.29.2). Sigh.
+  #
+  $ipv6_parameters = ($enable_ipv6 and ! $write_daemon_config) ? {
+    true => ['--ipv6',
+      $docker_network_v6 ? {
+        true => [],
+        default => ['--fixed-cidr-v6', $docker_network_v6],
+      }
+    ],
+    false => []
+  }
+
+  $_extra_parameters = flatten([
+    $docker_extra_parameters,
+    $ipv6_parameters,
+    ]).join(' ')
+
+
+  if $write_daemon_config {
+    if $docker_network =~ String[1] {
+      $default_address_pools = $docker_network
+    } else {
+      $default_address_pools = '172.16.0.0/12'
+    }
+    file {
+      '/etc/docker':
+        ensure => 'directory',
+        mode   => '0755',
+        ;
+      '/etc/docker/daemon.json':
+        ensure  => file,
+        mode    => '0644',
+        content => template('sunet/dockerhost/daemon.json.erb'),
+        ;
+    }
+
+    # Docker rejects options specified both from command line and in daemon.json
+    class {'docker':
+      manage_package              => false,
+      manage_kernel               => false,
+      use_upstream_package_source => false,
+      extra_parameters            => $_extra_parameters,
+      docker_command              => $docker_command,
+      daemon_subcommand           => $daemon_subcommand,
+      require                     => Package[$docker_package_name],
+    }
+  } else {
+    class {'docker':
+      storage_driver              => $storage_driver,
+      manage_package              => false,
+      manage_kernel               => false,
+      use_upstream_package_source => false,
+      dns                         => $_docker_dns,
+      extra_parameters            => $_extra_parameters,
+      docker_command              => $docker_command,
+      daemon_subcommand           => $daemon_subcommand,
+      tcp_bind                    => $_tcp_bind,
+      tls_enable                  => $tls_enable,
+      tls_cacert                  => $tls_cacert,
+      tls_cert                    => $tls_cert,
+      tls_key                     => $tls_key,
+      require                     => Package[$docker_package_name],
+    }
   }
 
   if $docker_network =~ String {
@@ -201,11 +249,6 @@ class sunet::dockerhost(
       mode    => '0755',
       content => template('sunet/dockerhost/docker-compose.erb'),
       ;
-    '/usr/bin/docker-compose':
-      # workaround: docker_compose won't find the binary in /usr/local/bin :(
-      ensure => 'link',
-      target => '/usr/local/bin/docker-compose',
-      ;
     }
 
   if $::sunet_has_nrpe_d == 'yes' {
@@ -232,6 +275,11 @@ class sunet::dockerhost(
         mode    => '0755',
         content => template('sunet/dockerhost/check_docker_containers.erb'),
         ;
+      '/usr/local/bin/restart_unhealthy_containers':
+        ensure  => file,
+        mode    => '0755',
+        content => template('sunet/dockerhost/restart_unhealthy_containers.erb'),
+        ;
       '/usr/local/bin/check_for_updated_docker_image':
         ensure  => file,
         mode    => '0755',
@@ -243,7 +291,16 @@ class sunet::dockerhost(
   if $run_docker_cleanup {
     # Cron job to remove old unused docker images
     sunet::scriptherder::cronjob { 'dockerhost_cleanup':
-      cmd           => '/bin/echo \'Running \"/usr/bin/docker system prune -af\" disabled since it removes too many tags\'',
+      cmd           => join([
+        'docker run --rm -v /var/run/docker.sock:/var/run/docker.sock',
+        'docker.sunet.se/sunet/docker-custodian dcgc',
+        '--exclude-image \'*:latest\'',
+        '--exclude-image \'*:staging\'',
+        '--exclude-image \'*:stable\'',
+        '--exclude-image \'*:*-staging\'',
+        '--exclude-image \'*:*-production\'',
+        '--max-image-age 24h',
+      ], ' '),
       special       => 'daily',
       ok_criteria   => ['exit_status=0', 'max_age=25h'],
       warn_criteria => ['exit_status=0', 'max_age=49h'],
diff --git a/templates/dockerhost/check_docker_containers.erb b/templates/dockerhost/check_docker_containers.erb
index 43d297ce..a7233468 100755
--- a/templates/dockerhost/check_docker_containers.erb
+++ b/templates/dockerhost/check_docker_containers.erb
@@ -1,6 +1,6 @@
 #!/usr/bin/env python3
 #
-# Copyright (c) 2016, 2018 SUNET
+# Copyright (c) 2016, 2018, 2019 SUNET
 # All rights reserved.
 #
 #   Redistribution and use in source and binary forms, with or
@@ -13,7 +13,7 @@
 #        copyright notice, this list of conditions and the following
 #        disclaimer in the documentation and/or other materials provided
 #        with the distribution.
-#     3. Neither the name of the NORDUnet nor the names of its
+#     3. Neither the name of the SUNET nor the names of its
 #        contributors may be used to endorse or promote products derived
 #        from this software without specific prior written permission.
 #
@@ -96,6 +96,12 @@ def parse_args():
                         default=default_runtime_warn,
                         help='Number of seconds a container should have been running to be considered non-critical',
                         )
+    parser.add_argument('--service',
+                        dest='service',
+                        type=str,
+                        default=None,
+                        help='Name of specific service to check',
+                        )
 
     return parser.parse_args()
 
@@ -107,7 +113,27 @@ def collect_init_d(args, logger):
     :returns: Docker container names
     :rtype: [str | unicode]
     """
-    return _collect_files('/etc/init.d', '^docker-(.+)$', logger)
+    if args.service:
+        regex = '^({})$'.format(args.service)
+    else:
+        regex = '^docker-(.+)$'
+
+    path = '/etc/init.d'
+
+    logger.debug('Looking for files in {!r} matching {!r}'.format(path, regex))
+    res = []
+    files = [this for this in os.listdir(path) if os.path.isfile(os.path.join(path, this))]
+    for this in files:
+        match = re.match(regex, this)
+        if match:
+            logger.debug('File {!s} matched regexp {!r}'.format(this, regex))
+            name = match.group(1)
+            if name.startswith('docker-'):
+                # strip the docker- prefix that will be part of the regexp if a service name was given as argument
+                name = name[8:]
+            res.append(name)
+    return res
+
 
 def collect_systemd(args, logger):
     """
@@ -116,45 +142,50 @@ def collect_systemd(args, logger):
     :returns: Docker container names
     :rtype: [str | unicode]
     """
-    return _collect_files('/etc/systemd/system', '^docker-(.+)\.service$', logger)
-
-def _collect_files(path, regex, logger):
-    logger.debug('Looking for files in {!r} matching {!r}'.format(path, regex))
     res = []
+    path = '/etc/systemd/system'
+    logger.debug('Looking for files in {!r}'.format(path))
     files = [this for this in os.listdir(path) if os.path.isfile(os.path.join(path, this))]
     for this in files:
-        match = re.match(regex, this)
-        if match:
-            logger.debug('File {!s} matched regexp {!s}'.format(this, regex))
-            res.append(match.group(1))
+        if not this.endswith('.service'):
+            continue
+        if args.service and this != '{}.service'.format(args.service):
+            continue
+
+        compose = collect_compose_services(os.path.join(path, this), logger)
+
+        if compose:
+            res += compose
+        else:
+            match = re.match('docker-(.+)\.service$', this)
+            if match:
+                res.append(match.group(1))
     return res
 
-def collect_compose_services(args, logger):
+def collect_compose_services(fn, logger):
     """
     Look for systemd services that start containers using Docker compose.
     The services should be created using sunet::docker_compose_service in order to have
     COMPOSE_FILE and SERVICE_NAME metadata in the top comment.
 
+    :type fn: str
+    :type logger: logging.Logger
+
     :returns: Docker container names
     :rtype: [str | unicode]
     """
     res = []
-    path = '/etc/systemd/system'
-    files = [os.path.join(path, this) for this in os.listdir(path) if this.endswith('.service') and os.path.isfile(os.path.join(path, this))]
-    if not files:
-        return []
-    re_compose_file = re.compile('^#\s*COMPOSE_FILE=(.+?)\s*$')
-    for this in files:
-        compose_file = _get_compose_metadata(this, re_compose_file, logger)
-        if compose_file:
-            # docker-compose uses directory of file as service-name
-            # e.g. for file /path/to/something/docker-compose.yml the service-name is 'something'
-            service_name = os.path.basename(os.path.dirname(compose_file))
-            res += _collect_compose_service(compose_file, service_name, logger)
+    re_compose_file = re.compile(r'^#\s*COMPOSE_FILE=(.+?)\s*$')
+    compose_file = _get_compose_metadata(fn, re_compose_file, logger)
+    if compose_file:
+        # docker-compose uses directory of file as service-name
+        # e.g. for file /path/to/something/docker-compose.yml the service-name is 'something'
+        service_name = os.path.basename(os.path.dirname(compose_file))
+        res += _collect_compose_service(compose_file, service_name, logger)
     return res
 
 def _get_compose_metadata(filename, re_compose_file, logger):
-    logger.debug('Inspecting systemd service file {!s}'.format(filename))
+    logger.debug('Trying to find compose-file reference in file {!s}'.format(filename))
     with open(filename) as fd:
         for line in fd.readlines():
             if not line.startswith('#'):
@@ -310,7 +341,6 @@ def main(args, logger):
 
     if args.systemd:
         expect += collect_systemd(args, logger)
-        expect += collect_compose_services(args, logger)
 
     logger.debug('Expecting the following Docker containers to be running: {!r}'.format(expect))
 
diff --git a/templates/dockerhost/docker-compose.erb b/templates/dockerhost/docker-compose.erb
index 45fcd97c..a5e3f711 100644
--- a/templates/dockerhost/docker-compose.erb
+++ b/templates/dockerhost/docker-compose.erb
@@ -19,10 +19,10 @@ IMAGE="<%= @compose_image %>:<%= @compose_version %>"
 
 # Setup options for connecting to docker host
 if [ -z "$DOCKER_HOST" ]; then
-    DOCKER_HOST="/var/run/docker.sock"
+    DOCKER_HOST='unix:///var/run/docker.sock'
 fi
-if [ -S "$DOCKER_HOST" ]; then
-    DOCKER_ADDR="-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST"
+if [ -S "${DOCKER_HOST#unix://}" ]; then
+    DOCKER_ADDR="-v ${DOCKER_HOST#unix://}:${DOCKER_HOST#unix://} -e DOCKER_HOST"
 else
     DOCKER_ADDR="-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH"
 fi
@@ -37,44 +37,72 @@ if [ -n "$COMPOSE_FILE" ]; then
 	echo "$0: Compose-file ${COMPOSE_FILE} does not exist, or is empty"
 	exit 1
     fi
-    compose_dir=$(dirname "${COMPOSE_FILE}")
+    COMPOSE_OPTIONS="$COMPOSE_OPTIONS -e COMPOSE_FILE=$COMPOSE_FILE"
+    compose_dir="$(dirname "$COMPOSE_FILE")"
+    # canonicalize dir, do not use realpath or readlink -f
+    # since they are not available in some systems (e.g. macOS).
+    compose_dir="$(cd "$compose_dir" && pwd)"
+fi
+if [ -n "$COMPOSE_PROJECT_NAME" ]; then
+    COMPOSE_OPTIONS="-e COMPOSE_PROJECT_NAME $COMPOSE_OPTIONS"
 fi
-# TODO: also check --file argument
 if [ -n "$compose_dir" ]; then
     VOLUMES="$VOLUMES -v $compose_dir:$compose_dir"
 fi
 if [ -n "$HOME" ]; then
-    VOLUMES="$VOLUMES -v $HOME:$HOME -v $HOME:/root" # mount $HOME in /root to share docker.config
+    VOLUMES="$VOLUMES -v $HOME:$HOME -e HOME" # Pass in HOME to share docker.config and allow ~/-relative paths to work.
 fi
+i=$#
+while [ $i -gt 0 ]; do
+    arg=$1
+    i=$((i - 1))
+    shift
+
+    case "$arg" in
+        -f|--file)
+            value=$1
+            i=$((i - 1))
+            shift
+            set -- "$@" "$arg" "$value"
 
-# Make volumes of all 'yml' files passed as arguments
-for arg in $*; do
-    case $arg in
-	"/"*".yml")
-	    if [ ! -f "${arg}" ]; then
-		echo "$0: YAML file argument ${arg} is not a file"
-		exit 1
-	    fi
-	    VOLUMES="$VOLUMES -v ${arg}:${arg}:ro"
-	    ;;
-	*".yml")
-	    if [ ! -f "${PWD}/${arg}" ]; then
-		echo "$0: YAML file argument ${arg} in ${PWD} is not a file"
-		exit 1
-	    fi
-	    VOLUMES="$VOLUMES -v ${PWD}/${arg}:${PWD}/${arg}:ro"
-	    ;;
-	*)
-	    ;;
+            file_dir=$(realpath "$(dirname "$value")")
+            VOLUMES="$VOLUMES -v $file_dir:$file_dir"
+        ;;
+		# Make volumes of all 'yml' files passed as arguments
+		"/"*".yml")
+			if [ ! -f "${arg}" ]; then
+			echo "$0: YAML file argument ${arg} is not a file"
+			exit 1
+			fi
+			VOLUMES="$VOLUMES -v ${arg}:${arg}:ro"
+			;;
+		*".yml")
+			if [ ! -f "${PWD}/${arg}" ]; then
+			echo "$0: YAML file argument ${arg} in ${PWD} is not a file"
+			exit 1
+			fi
+			VOLUMES="$VOLUMES -v ${PWD}/${arg}:${PWD}/${arg}:ro"
+			;;
+        *) set -- "$@" "$arg" ;;
     esac
 done
 
+# Setup environment variables for compose config and context
+ENV_OPTIONS=$(printenv | sed -E "/^PATH=.*/d; s/^/-e /g; s/=.*//g; s/\n/ /g")
+
 # Only allocate tty if we detect one
-if [ -t 1 ]; then
-    DOCKER_RUN_OPTIONS="-t"
+if [ -t 0 ] && [ -t 1 ]; then
+    DOCKER_RUN_OPTIONS="$DOCKER_RUN_OPTIONS -t"
 fi
-if [ -t 0 ]; then
-    DOCKER_RUN_OPTIONS="$DOCKER_RUN_OPTIONS -i"
+
+# Always set -i to support piped and terminal input in run/exec
+DOCKER_RUN_OPTIONS="$DOCKER_RUN_OPTIONS -i"
+
+
+# Handle userns security
+if docker info --format '{{json .SecurityOptions}}' 2>/dev/null | grep -q 'name=userns'; then
+    DOCKER_RUN_OPTIONS="$DOCKER_RUN_OPTIONS --userns=host"
 fi
 
-exec docker run --rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w "$(pwd)" $IMAGE "$@"
+# shellcheck disable=SC2086
+exec docker run --rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $ENV_OPTIONS $VOLUMES -w "$(pwd)" $IMAGE "$@"
diff --git a/templates/dockerhost/systemd_dropin_nftables_ns.conf.erb b/templates/dockerhost/systemd_dropin_nftables_ns.conf.erb
index 14a47240..3cf2af5e 100644
--- a/templates/dockerhost/systemd_dropin_nftables_ns.conf.erb
+++ b/templates/dockerhost/systemd_dropin_nftables_ns.conf.erb
@@ -44,7 +44,15 @@ ExecStartPre=-/sbin/ip -6 route list
 # Docker enables IP forwarding itself, but only in it's namespace of course. We need to enable it
 # in the hosts namespace too.
 ExecStartPre=/usr/bin/nsenter -t 1 -n -- /sbin/sysctl -w net.ipv4.ip_forward=1 net.ipv6.conf.all.forwarding=1
-
+# Un-NATed packets from the containers appear quite frequently on the to_docker interface (looks like RST
+# packets when then connection is already closed for example), and gets logged as martian packets. Disable that.
+#
+# For some reason, this gets logged even though net.ipv4.conf.to_docker.log_martians = 0:
+#
+#   [Mon Mar 21 07:36:02 2022] IPv4: martian source 130.242.x.y from 172.16.8.4, on dev to_docker
+#
+# on Linux 4.15 at least, so we disable all martian logging.
+ExecStartPre=/sbin/sysctl -w net.ipv4.conf.all.log_martians=0
 
 # Setup named namespace for easier troubleshooting from the outside.
 ExecStartPost=-/bin/mkdir -p /var/run/netns
