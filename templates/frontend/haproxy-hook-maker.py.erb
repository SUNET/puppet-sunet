#!/usr/bin/env python

import os
import sys
import socket
import logging
import argparse
import requests

logger = None

_defaults = {'stats_url': 'http://127.0.0.1:9000/haproxy_stats;csv',
             'syslog': False,
             'debug': False,
             'interface': 'lo',
             }


def parse_args(defaults):
    parser = argparse.ArgumentParser(description = 'haproxy status checker',
                                     add_help = True,
                                     formatter_class = argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument('site',
                        nargs='+',
                        metavar='STR',
                        help='Site check string. XXX format to be documented here later.',
    )
    parser.add_argument('--debug',
                        dest = 'debug',
                        action = 'store_true', default = defaults['debug'],
                        help = 'Enable debug operation',
    )
    parser.add_argument('--syslog',
                        dest = 'syslog',
                        action = 'store_true', default = defaults['syslog'],
                        help = 'Enable syslog output',
    )
    parser.add_argument('--up',
                        dest = 'up',
                        action = 'store_true', default = False,
                        help = 'Generate a script to bring the site UP',
    )
    parser.add_argument('--down',
                        dest = 'down',
                        action = 'store_true', default = False,
                        help = 'Generate a script to bring the site DOWN',
    )
    parser.add_argument('--interface',
                        dest = 'interface',
                        default = defaults['interface'],
                        help = 'Interface with service IPs',
                        metavar = 'STR',
    )
    args = parser.parse_args()

    if not (args.up or args.down) or (args.up and args.down):
        sys.stderr.write('{}: One of --up and --down (and only one) must be provided\n'.format(sys.argv[0]))
        return None

    return args


def output_hook(params, args, ipver):
    logger.debug('Processing site {}, params {}'.format(params['site'], params))
    site = params['site']
    sorted_ips = _local_pref_sort_ips(params['index'], params[ipver])
    logger.debug('Re-sorted IPs {} -> {} based on index {}'.format(params[ipver], sorted_ips, params['index']))
    bgp_med = 0
    bgp = []
    ip_add = []
    count=1
    for ip in sorted_ips:
        if ':' in ip:
            ip_slash = ip + '/128'
        else:
            ip_slash = ip + '/32'

        if args.down:
            bgp.append('echo "withdraw route {} next-hop self"'.format(ip_slash))
            # Don't delete IP address from interface on DOWN events - scary.
            continue

        bgp_med += 100

        ip_add.append('ip addr add {} dev {}'.format(ip, args.interface))

        logger.debug('Site {}, address {}/{} -> announce {} with BGP MED {}'.format(
            site, count, len(sorted_ips), ip, bgp_med))
        bgp.append('echo "announce route {} next-hop self med {}"'.format(ip_slash, bgp_med))
        count += 1
    return ip_add + bgp


def _local_pref_sort_ips(index, ips):
    """
    Three load balancers named A, B and C should all announce
    service IP 1, 2 and 3 with different BGP MED (lower MED wins).

    A should announce 1 with the lowest MED, and B should announce
    2 with the lowest MED.

    Re-sort the input list of IPs to start with the one specified by the index.
    """
    return ips[index - 1:] + ips[:index - 1]


def main(myname = 'frontend-script-maker', args = None, logger_in = None, defaults = _defaults):
    if not args:
        args = parse_args(defaults)
    if not args:
        return False

    global logger
    # initialize various components
    if logger_in:
        logger = logger_in
    else:
        logger = logging.getLogger(myname)
        if args.debug:
            logger.setLevel(logging.DEBUG)
            # log to stderr when debugging
            formatter = logging.Formatter('%(asctime)s %(name)s %(threadName)s: %(levelname)s %(message)s')
            stream_h = logging.StreamHandler(sys.stderr)
            stream_h.setFormatter(formatter)
            logger.addHandler(stream_h)
    if args.syslog:
        syslog_h = logging.handlers.SysLogHandler()
        formatter = logging.Formatter('%(name)s: %(levelname)s %(message)s')
        syslog_h.setFormatter(formatter)
        logger.addHandler(syslog_h)

    output = ['#!/bin/sh']
    for this in args.site:
        action = 'UP'
        if args.down:
            action = 'DOWN'
        output += ['', '# Site {} commands generated from \'{}\''.format(action, this)]
        # Parse strings such as 'site=www.dev.eduid.se; index=1; ipv4=1,2,3; ipv6=a,b,c'
        params = {}
        for kv in this.split(';'):
            k, v = kv.split('=')
            k = k.strip()
            v = v.strip()
            if k == 'ipv4' or k == 'ipv6':
                v = v.split(',')
            if k == 'index':
                v = int(v)
            params[k] = v
        logger.debug('Parsed params {}'.format(params))
        if 'ipv4' in params:
            res = output_hook(params, args, 'ipv4')
            if res:
                output += res
        if 'ipv6' in params:
            res = output_hook(params, args, 'ipv6')
            if res:
                output += res

    print('\n'.join(output))
    return output != []


if __name__ == '__main__':
    try:
        progname = os.path.basename(sys.argv[0])
        res = main(progname)
        if res is True:
            sys.exit(0)
        if res is False:
            sys.exit(1)
        sys.exit(int(res))
    except KeyboardInterrupt:
        sys.exit(0)
