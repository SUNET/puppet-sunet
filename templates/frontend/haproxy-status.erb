#!/usr/bin/env python

import os
import sys
import socket
import logging
import argparse

logger = None

_defaults = {'socket_fn': '/opt/frontend/haproxy/run/stats',
             'syslog': False,
             'debug': False,
             'interface': 'lo',
             }


def parse_args(defaults):
    parser = argparse.ArgumentParser(description = 'haproxy status checker',
                                     add_help = True,
                                     formatter_class = argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument('site',
                        nargs='+',
                        metavar='STR',
                        help='Site check string. XXX format to be documented here later.',
    )
    parser.add_argument('--debug',
                        dest = 'debug',
                        action = 'store_true', default = defaults['debug'],
                        help = 'Enable debug operation',
    )
    parser.add_argument('--syslog',
                        dest = 'syslog',
                        action = 'store_true', default = defaults['syslog'],
                        help = 'Enable syslog output',
    )
    parser.add_argument('--socket_fn',
                        dest = 'socket_fn',
                        default = defaults['socket_fn'],
                        help = 'haproxy socket',
                        metavar = 'PATH',
    )
    parser.add_argument('--interface',
                        dest = 'interface',
                        default = defaults['interface'],
                        help = 'Interface with service IPs',
                        metavar = 'STR',
    )
    args = parser.parse_args()
    return args


def haproxy_execute(cmd, args):
    logger.debug('opening AF_UNIX socket {} for command "{}"'.format(args.socket_fn, cmd))
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.connect(args.socket_fn)
    client.send(cmd + '\n')

    data = ''
    while True:
        this = client.recv(1)
        if not this:
            break
        data += this

    logger.debug('haproxy result: {}'.format(data))
    return data


def get_status(args):
    data = haproxy_execute('show stat', args)
    if not data:
        return None
    lines = data.split('\n')
    if not lines[0].startswith('# '):
        logger.error('Unknown status response from haproxy: {}'.format(data))
    fields = lines[0][2:].split(',')
    if len(lines) < 2:
        logger.warning('haproxy did not return status for any backends: {}'.format(data))
        return None
    status = {}
    lines = lines[1:]
    for line in lines:
        if not line:
            continue
        values = line.split(',')
        if len(values) != len(fields):
            logger.warning('Values ({}) does not match legend ({}): {}'.format(len(values), len(fields), line))
            continue
        site = values[0]
        host = values[1]
        if site not in status:
            status[site] = {}
        status[site][host] = {}
        for i in range(len(fields)):
            status[site][host][fields[i]] = values[i]

    for site in status.keys():
        for backend in status[site].keys():
            logger.debug('Site {} backend {}, status {}'.format(site, backend, status[site][backend].get('status')))
    return status


def check_site(params, data, my_ips):
    logger.debug('Processing site {}, params {}, backends {}'.format(params['site'], params, data.keys()))
    site = params['site']
    backends_up = _count_backends_up(data)
    logger.debug('Backends UP: {}'.format(backends_up))
    sorted_ips = _local_pref_sort_ips(params['index'], params['ips'])
    logger.debug('Re-sorted IPs {} -> {} based on index {}'.format(params['ips'], sorted_ips, params['index']))
    base_pref = 0
    res = []
    count = 1
    # Reverse IP list since higher local-preference wins
    sorted_ips.reverse()
    for ip in sorted_ips:
        if ':' in ip:
            ip_slash = ip + '/128'
        else:
            ip_slash = ip + '/32'

        if ip not in my_ips:
            logger.debug('Withdrawing service IP {} not in my list: []'.format(ip, my_ips))
            res.append('withdraw route {} next-hop self'.format(ip_slash))
            continue

        if not backends_up:
            # Even when there are NO backends up, we want to announce the routes in order
            # to be able to serve a fail-whale page. Local preference should be very low
            # though, so that if another load balancer see any backends available it will
            # attract all traffic.
            base_pref += 10
            local_pref = base_pref
        else:
            base_pref += 1000
            local_pref = base_pref + (backends_up * 10)

        logger.debug('Site {}, address {}/{}, backends up {} -> announce {} with local pref {}'.format(
            site, count, len(sorted_ips), backends_up, ip, local_pref))
        res.append('announce route {} next-hop self local-preference {}'.format(ip_slash, local_pref))
        count += 1
    # for the humans
    res.reverse()
    return res


def _local_pref_sort_ips(index, ips):
    """
    Three load balancers named A, B and C should all announce
    service IP 1, 2 and 3 with different local prefs.

    A should announce 1 with the highest preference, and B should announce
    2 with the highest local preference.

    Re-sort the input list of IPs to start with the one specified by the index.
    """
    return ips[index - 1:] + ips[:index - 1]

def _count_backends_up(data):
    backends = [x for x in data.keys() if x != 'BACKEND' and data[x]['status'] == 'UP']
    return len(backends)


def _get_interface_ips(interface):
    # Need a list of all the service addresses which _actually_ have a chance of
    # working at this frontend. Not one of my proudest hacks.
    res = []
    for this in os.popen('ip addr list {}'.format(interface)).readlines():
        this = this.strip()
        if this.startswith('inet') or this.startswith('inet6'):
            addr = this.split(' ')[1]
            ip = addr.split('/')[0]
            if ip not in ['127.0.0.1', '::1']:
                res.append(ip)
    return res


def main(myname = 'haproxy-status', args = None, logger_in = None, defaults = _defaults, my_ips=None):
    if not args:
        args = parse_args(defaults)

    global logger
    # initialize various components
    if logger_in:
        logger = logger_in
    else:
        logger = logging.getLogger(myname)
        if args.debug:
            logger.setLevel(logging.DEBUG)
            # log to stderr when debugging
            formatter = logging.Formatter('%(asctime)s %(name)s %(threadName)s: %(levelname)s %(message)s')
            stream_h = logging.StreamHandler(sys.stderr)
            stream_h.setFormatter(formatter)
            logger.addHandler(stream_h)
    if args.syslog:
        syslog_h = logging.handlers.SysLogHandler()
        formatter = logging.Formatter('%(name)s: %(levelname)s %(message)s')
        syslog_h.setFormatter(formatter)
        logger.addHandler(syslog_h)


    if my_ips is None:
        my_ips = _get_interface_ips(args.interface)
        logger.debug('Found addresses {} on interface {}'.format(my_ips, args.interface))

    status = get_status(args)

    output = []
    for this in args.site:
        #import json
        #params = json.loads(this)
        params = {}
        # Parse strings such as 'site=www.dev.eduid.se; index=1; ips=1,2,3'
        for kv in this.split(';'):
            k, v = kv.split('=')
            k = k.strip()
            v = v.strip()
            if k == 'ips':
                v = v.split(',')
            if k == 'index':
                v = int(v)
            params[k] = v
        logger.debug('Parsed params {}'.format(params))
        site = params['site']
        if site not in status:
            logger.debug('Site {} not found in haproxy status'.format(site))
            continue
        res = check_site(params, status[site], my_ips)
        if res:
            output += res

    print('\n'.join(output))
    return output != []


if __name__ == '__main__':
    try:
        progname = os.path.basename(sys.argv[0])
        res = main(progname)
        if res is True:
            sys.exit(0)
        if res is False:
            sys.exit(1)
        sys.exit(int(res))
    except KeyboardInterrupt:
        sys.exit(0)
