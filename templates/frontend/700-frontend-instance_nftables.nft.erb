#
# SNAT IPv6 packages _from_ haproxy. The IPv6 address used for outgoing connections will always
# be in the range fd0c::/64 (IP address added to sarimner0 by configure-container-network).
#
# Docker will NAT IPv4 packages for us, and that SNAT is handled in 200-sunet_dockerhost.nft.
# IPv6 however is sadly dysfunctional in docker-compose, so for Sunet frontend instances, we
# manage the IPv6 ourselves.
#
add rule inet filter forward iifname to_<%= @instance -%> oif eth0 counter accept comment "Allow traffic from frontend instance <%= @instance -%>"
#
# 200-dockerhost_nftables.nft currently sets up SNAT for all containers, otherwise this could be used:
#add rule ip6 nat postrouting ip6 saddr { fd0c::/64 } oif eth0 counter masquerade comment "SNAT traffic from frontend instance <%= @instance -%>y"

#
# Allow exposed ports from eth0 to frontend instance docker containers
<% if @tcp_dport.is_a? String -%>
add rule inet filter forward iif eth0 oifname to_<%= @instance -%> tcp <%= @tcp_dport -%> counter accept comment "Allow traffic to frontend instance <%= @instance -%>"
# icmp is necessary for path-mtu
add rule inet filter forward iif eth0 oifname to_<%= @instance -%> ip protocol icmp counter accept comment "Allow traffic to frontend instance <%= @instance -%>"
add rule inet filter forward iif eth0 oifname to_<%= @instance -%> ip6 nexthdr icmpv6 counter accept comment "Allow traffic to frontend instance <%= @instance -%>"
# We could filter on destination address too, but I'm not sure it would be worth the extra clock cylces
# add rule inet filter forward iif eth0 ip  daddr <%= @frontend_ips_v4 -%> tcp <%= @tcp_dport -%> counter accept comment "Allow traffic to frontend instance <%= @instance -%>"
# add rule inet filter forward iif eth0 ip6 daddr <%= @frontend_ips_v6 -%> tcp <%= @tcp_dport -%> counter accept comment "Allow traffic to frontend instance <%= @instance -%>"
<% end -%>
